---
title: "References & Pointers"
# subtitle: "Control Flow"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: simple   # other themes: beige, blood, dark, dracula, league, moon, night, serif, simple, sky, solarized
        mouse-wheel: true
        highlight-style: github
        slide-number: true
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        code-block-bg: false          # <-- remove white background in code blocks
        # code-block-border-left: false # optional: remove left border
        # highlight-style: monokai      # good for dark images
        toc: true
        toc-depth: 1
        toc-title: Presentation Outline
        chalkboard: true
        css: simple.css
---

# Introduction to compound data types

## Quick intro
&#10149; Let us write a program doing maths with fractions:

::: {#lst-function-program lst-cap="A program for doing maths in fractions. Filename=`fraction_program.cpp`"}
```{ .cpp}
{{< include ./cpp/fraction_program.cpp >}}
```
:::
&#10149; Of course, we want to have a data type representing the concept of Fraction.

## Quick intro

&#10149; Now imagine that we are writing a program that needs to keep a list of employee IDs.
```{.cpp}
int main()
{
    int id1 { 42 };
    int id2 { 24 };
    int id3 { 162 };
    
    double salary1 { 42123.3 };
    double salary2 { 43784.5 };
    double salary3 { 39469.2 };

    // Names, roles, job titles and blah blah
}
```
&#10149; What if we had $100$ employes? Clearly, this naive approach simply does not scale.

## Quick intro: Compound data types

Fortunately, C++ supports **compound data types** (sometimes called **composite data types**).

- **Compound data types** are types that are defined in terms of other existing data types.
- **Compound data types** have additional properties & behaviros that make the useful for certain types of problems.


## Compound data types

C++ supports the following compound types.

::: {.fragment}
### Fundamental Compound Types (built-in)
- Functions (we already learned)
- C-style arrays
- Pointers
- References
:::

::: {.fragment}
### User-defined Compound Types
- Structs (using keyword `struct`)
- Classes (using keyword `class`)
- Enumerations (using keyword `num` or `enum class`)
- Unions (using `union`)
:::


## Compound data types
We shall learn most of them (not all of them due to time constraints).

- I aim at cover the following topics in the live lectures 
  - references
  - pointers
  - C-style arrays
  - structs
  - classes
  - enumerations.
- You will see that structs and classes are very similar, and studying one carefully is enough.

## Function is a compound data type

In fact, we've been using one compound type regularly: **Functions**.

&#10149; Consider this function
```{.cpp}
void do_something(int x, double y)
```
The type of this function is 
```{.cpp}
void(int, double)
```

# Value categories (lvalues and rvalues)

Before we discuss lvalue references, we take a detour to learn **lvalue**.

## Expression
- **Recall**: An **expression** is *a combination of literals, variables, operators and function calls that can be executed to produce a singular value*.
```{.cpp}

#include <iostream>
double multiply(double x, double y) { return x * y; }
double add(double x, double y) { return x + y; }
int main()
{
    // The expression add(2 + multiply(3, 4), 3) evaluates to the value 15.
    std::cout << add(2 + multiply(3, 4), 3) << '\n'; 

    return 0;
}
```


### Properties of an expression

- To help determine how expressions should evaluate and where they can be used, all expressions in C++ has two properties:
  - a [**type**]{style="color:red"} category
  - a [**value**]{style="color:red"} gategory
  
## The type of an expression

The type of an expression is equivalent to the type of the value, object, or function that results from the evaluated expression.

```{.cpp}
int main()
{
    auto v1 { 12 / 4 }; // int / int => int
    auto v2 { 12.0 / 4 }; // double / int => double

    return 0;
}
```

## The type of an expression
The compiler can use the type of an expression to determine whether an expression is valid in a given context.
```{.cpp}
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print("foo"); // error: print() was expecting an int argument, we tried to pass in a string literal

    return 0;
}
```

## The value category of an expression

&#10149; Consider the following program
```{.cpp}
int main()
{
    int x {};
    x = 5;      // valid: we can assign 5 to x
    5 = x;      // error: cannot assign value of x to literal value 5
    return 0;
}
```
- One of these assigments is valid (`x = 5`) and the other is not (assigning `x` to `5`, what the hell?)
- As a human with common sense, we can clearly see `5 = x` does not make sense.

**Question**&nbsp; But how does the compiler know which expression can legally appear on either side of an assignment statement?

::: {.fragment}
**Answer**&nbsp; The answer lies in the second property of expressions: [value category]{style="color:red"}
:::

## The value category of an expression
::: {.incremental}
- Prior to C++11, there were only two possible value categories: **lvalue** and **rvalue**
- In C++11, three additional value categories, **glvalue**, **prvalue** and **xvalue** were added to support new feature called **move semantics**
- We shall focus on *lvalue* and *rvalue* first.
:::


# Regarding lvalue and rvalue expressions

## lvalue expression

::: {.incremental}
- An **lvalue** is an an expression that evaluates to an identifiable object or function (or bit-field).
- Unfortunately, the term "identity" is used by the C++ standard, but is not well-defined.
- An entity (such as an object or function) that has an identity can be differentiated from other similar entities (typically by comparing the addresses of the entity)
- Entities with identities can be accessed via an identifier, reference, or pointer, and typically have a lifetime longer than a single expression or statement.
:::

::: {.fragment}
> Loosely speaking, we can think of identifier as the name of a variable, a function because we can identify them by name.
:::

::: {.fragment}
&#10149; Look at this example
```{.cpp}
int main()
{
    int x { 5 };
    int y { x };        // x is an lvalue expression

    return 0;
}
```
:::

## rvalue expression

::: {.incremental}
- An **rvalue** is an expression that is not an **lvalue**.
- rvalue expressions evaluate to a value.
- Commonly seen rvalues include 
  - literals (except C-style string literals -- which are lvalues)
  - return value of functions
  - return value of operators that return by value
:::

::: {.fragment}
> **rvalues** are not identifiable (meaning they have to be used immediately), and only exist within the scope of the expression in which they are used.
:::

## rvalue expression: Example

::: {#lst-rvalue-example lst-cap="rvalue expression example. Filenmae=`rvalue_expression.example.cpp`"}
```{.cpp}
{{< include ./cpp/rvalue_expression_example.cpp >}}
```
:::

- `return5()`, `x + 1` and `static_cast<int>(d)` are rvalues because these expressions produce temporary values that are not identifiable objects.

## lvalue expressions versus rvalue expressions

It is hard to remember/understand lvalue expressions versus rvalue expressions. But we can summarize

> **Key insight**
>
> [**lvalue**]{style="color:red"} expressions evaluate to an [**identifiable object**]{style="color:red"}
> [**rvalue**]{style="color:blue"} expressions evalute to a [**value**]{style="color:blue"}.

## Value categories and operators

Unless otherwise specified, [**operators expect their operands to be rvalues**]{style="color:red"}.

::: {#lst-rvalue-example lst-cap="rvalue expression example. Filenmae=`value_categories_in_operators.cpp`"}
```{.cpp}
{{< include ./cpp/value_categories_in_operators.cpp >}}
```
:::


## Come back to the original question: `x = 5` vs `5 = x`

We can answer the question about why `x = 5` is valid but `5 = x` is not valid:

&#10149; **An assignment operation requires its left operand to be a modifiable lvalue expression.**

&#10149; The assignment `5 = x` fails because the left operand expression `5` is an rvalue, not a modifiable lvalue.

```{.cpp}
int main()
{
    int x{};

    // Assignment requires the left operand to be a modifiable 
    // lvalue expression and the right operand to be an rvalue 
    // expression
    x = 5;  // valid: x is a modifiable lvalue expression 
            // and 5 is an rvalue expression

    5 = x;  // error: 5 is an rvalue expression and x 
            // is a modifiable lvalue expression

    return 0;
}
```

## You might ask: How about `y = x`

You might ask now: How about `y = x`? 


&#10149;&nbsp; It is a legitimate question. Look at this

```{.cpp}
int main()
{
    int x{ 1 };
    int y{ 2 };

    x = y; // y is not an rvalue, but this is legal

    return 0;
}
```

::: {.fragment}
**Question**&nbsp; What is your opinion about this?
:::

## lvalue-to-rvalue conversion

```{.cpp}
int main()
{
    int x{ 1 };
    int y{ 2 };

    x = y; // y is not an rvalue, but this is legal

    return 0;
}
```
::: {.fragment}
&#10140; The lvalue expression `y` undergoes an lvalue-to-rvalue conversion, which evaluates `y` to produce an rvalue (value `2`).
:::

::: {.fragment}
- In cases where an rvalue is expected but an lvalue is provided, the lvalue will undergo an [**lvalue-to-rvalue conversion**]{style="color:red"}. 
- This basically means the *lvalue* is evaluted to produce its value, which is an *rvalue*.
::: 

::: {.fragment}
> **Key insight**
>
> An lvalue will implicitly convert to an rvalue. [This means an lvalue can be used anywhere an rvalue is expected.]{style="color:magenta"}. [An rvalue, on the other hand, will not implicitly convert to an lvalue.]{style="color:blue"}
:::

## lvalue-to-rvalue conversion

&#10149; Consider this example
```{.cpp}
int main()
{ 
    int x { 42 };

    x = x + 1;

    return 0;
}
```

- The variable `x` is being used in two different contexts.
- On the left side of assignment operator (`=`), `x` is an lvalue expression that evaluates to the variable `x`.
- On the right side of the assignment operator (`=`), `x` undergoes an lvalue-to-rvalue conversion. 
- Then, `x` is evaluated to value `42` so that it can be used as the left operand of `operator+`.
- `operator+` returns the *rvalue* expression `43`.

## How to differentiate lvalues and rvalues



- **lvalue expressions** are those that evaluate to functions or identifiable objects (including variables) that [**persist beyond the end of the expression**]{style="color:red"}.
- **rvalue expressions** are those that evaluate to values, including literals and temporary objects that [**do not persist beyond the end of the expression**]{style="color:blue"}.


## A program telling what kind of expression something is

::: {#lst-rvalue-example lst-cap="rvalue expression example. Filenmae=`tell_value_categories.cpp`"}
```{.cpp}
{{< include ./cpp/tell_value_categories.cpp >}}
```
:::

# lvalue references

## References

A [**reference**]{style="color:red"} is an alias for an existing object.

- Once a reference has been defined, any operation on the reference is applied to the object being referenced.
- We can use a reference to read or modify the object being referenced.

**Note**&nbsp; 

- Although references might seem silly, useless or redundant, they are used everywhere in C++. 
- Otherwise, people won't introduce this concept.